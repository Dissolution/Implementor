using System.Diagnostics;
using System.Text;
using Microsoft.CodeAnalysis.Text;
using static Implementor.AttributeSource;

namespace Implementor;

[Generator(LanguageNames.CSharp)]
public sealed class ImplementationsGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
#if DEBUG
        // if (!Debugger.IsAttached)
        // {
        //     Debugger.Launch();
        // }

        //Debugger.Break();
#endif

        // Filter to all type declarations with our Implement attribute
        var typeDeclarations = context.SyntaxProvider
            .ForAttributeWithMetadataName(
                fullyQualifiedMetadataName: ImplementAttribute.FullyQualifiedName,
                predicate: static (syntaxNode, _) => syntaxNode is TypeDeclarationSyntax,
                transform: static (ctx, _) => (TypeDeclarationSyntax)ctx.TargetNode)
            .Where(t => t is not null)!;

        // Combine with Compilation
        var compilationAndTypeDeclarations = context.CompilationProvider
            .Combine(typeDeclarations.Collect());

        Console.WriteLine(Assembly.GetExecutingAssembly().Location);
        
        // Send for further processing
        context.RegisterSourceOutput(compilationAndTypeDeclarations,
            static (sourceContext, catd) => Process(catd.Left, sourceContext, catd.Right));
    }

    private static void Process(
        Compilation compilation,
        SourceProductionContext sourceProductionContext,
        ImmutableArray<TypeDeclarationSyntax> typeDeclarations)
    {
        // If we have nothing to process, exit
        if (typeDeclarations.IsDefaultOrEmpty) return;

        // Cancellation support
        var token = sourceProductionContext.CancellationToken;
        token.ThrowIfCancellationRequested();

        // Get the symbol for ImplementAttribute
        var implementAttributeSymbol = compilation
            .GetTypesByMetadataName(ImplementAttribute.FullyQualifiedName)
            .FirstOrDefault();
        if (implementAttributeSymbol is null)
            throw new InvalidOperationException($"Could not find {ImplementAttribute.FullyQualifiedName}");

        // As per several examples, we need a distinct list or a grouping on SyntaxTree
        // I'm going with System.Text.Json's example
        foreach (var group in typeDeclarations.GroupBy(static td => td.SyntaxTree))
        {
            token.ThrowIfCancellationRequested();
            SyntaxTree syntaxTree = group.Key;
            SemanticModel semanticModel = compilation.GetSemanticModel(syntaxTree);
            CompilationUnitSyntax unitSyntax = (syntaxTree.GetRoot(token) as CompilationUnitSyntax)!;

            // We're building Implementation
            using var fileBuilder = new CSharpFileBuilder()
                .AutoGeneratedHeader()
                .Nullable(true)
                .Namespace("Implementor");
            var implementations = new List<InterfaceImplementation>();
            
            // Now, process each thing our attribute is on
            foreach (TypeDeclarationSyntax typeDeclaration in typeDeclarations)
            {
                // Type's Symbol
                INamedTypeSymbol? typeSymbol = semanticModel.GetDeclaredSymbol(typeDeclaration) as INamedTypeSymbol;
                if (typeSymbol is null)
                {
                    throw new InvalidOperationException($"Could not get Declared {nameof(INamedTypeSymbol)} for {nameof(TypeDeclarationSyntax)}");
                }

                // Find this type's exact ImplementAttribute
                AttributeData? implementAttributeData = typeSymbol
                    .GetAttributes()
                    .FirstOrDefault(attr => string.Equals(attr.AttributeClass?.GetFullName(), ImplementAttribute.FullyQualifiedName));

                if (implementAttributeData is null)
                {
                    throw new InvalidOperationException($"Could not get find our {ImplementAttribute.FullyQualifiedName}");
                }

                // Generate this type's implementation
                var builder = new ImplementationBuilder(typeDeclaration, typeSymbol, implementAttributeData);

                var sourceFile = builder.GetSourceFile();
                sourceProductionContext.AddSource(
                    hintName: $"{sourceFile.Namespace}.{sourceFile.ClassName}.g.cs",
                    sourceText: SourceText.From(sourceFile.Code, Encoding.UTF8));
                implementations.Add(sourceFile);
            }
            
            foreach (var implementation in implementations)
            {
                fileBuilder.Using(implementation.Namespace);
            }
            
            fileBuilder.Code
                .Append($$"""
                    public static class Implementation
                    {
                        {{(CBA)(cb => Append1(cb, implementations))}}
                    }
                    """);
            
            var icode = fileBuilder.GetSourceCode();
            
            sourceProductionContext.AddSource(
                hintName: "Implementor.Implementation.g.cs",
                sourceText: fileBuilder.GetSourceText());
        }
    }

    private static void Append1(CodeBuilder code, IEnumerable<InterfaceImplementation> implementations)
    {
        code.Delimit(cb => cb.NewLine(), implementations, (cb, impl) =>
        {
            cb.Append($"public static {impl.InterfaceName} Of{impl.InterfaceName}(");
            if (impl.CtorParamTypes.Length == 0)
            {
                cb.Append($") => new {impl.ClassName}();").NewLine();
            }
            else
            {
                throw new NotImplementedException();
            }
        });
    }
}